# 2020 HDU Multi-University Training Contest 3

[toc]



Rank 101ï¼Œå‰æœŸå¤§èƒœåˆ©ï¼Œä¸€åº¦è¿›è¿‡å‰ $15$ ï¼Œä¸­åæœŸé›ªå´©...



<table boder="2">
<tr align="center">
<td> </td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
<td>I</td>
<td>J</td>
<td>K</td>
</tr>
<tr align="center">
<td>èµ›æ—¶</td>
<td> </td>
<td> </td>
<td> </td>
<td>ğŸˆ</td>
<td>ğŸˆ</td>
<td>ğŸ’­</td>
<td>ğŸ’¡</td>
<td>ğŸˆ</td>
<td>ğŸˆ</td>
<td>ğŸ’­</td>
<td> </td>
</tr>
<tr align="center">
<td>èµ›å</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
</table>



### D. Tokitsukaze and Multiple (ç­¾åˆ°)

$n$ é•¿æ•°ç»„ï¼Œæ¯æ¬¡å¯ä»¥æŒ‘é€‰ç›¸é‚»çš„ä¸¤ä¸ªåˆå¹¶æˆå®ƒä»¬çš„å’Œï¼Œæœ€å¤§åŒ–æ•°ç»„é‡Œ $p$ çš„å€æ•°çš„ä¸ªæ•°ã€‚

æŠŠå‰ç¼€å’Œæ¨¡ $p$ å­˜ä¸‹æ¥è´ªå¿ƒåœ°åˆå¹¶å³å¯ã€‚

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,p,ans,pre;
unordered_set<int> s;

void solve()
{
    ans=pre=0;
    scanf("%d%d",&n,&p);
    s.insert(0);
    for(int i=1,x;i<=n;i++)
    {
        scanf("%d",&x);
        pre=(pre+x)%p;
        if(!s.insert(pre).second)
        {
            s.clear();
            s.insert(0);
            pre=0;
            ans++;
        }
    }
    printf("%d\n",ans);
}

int main()
{
    int _;
    scanf("%d",&_);
    while(_--) solve();
    return 0;
}
```



### E. Little W and Contest (å¹¶æŸ¥é›†+ç®€å•è®¡æ•°)

$n$ ä¸ªäººï¼Œåˆ†ä¸ºä¸¤ç±»ï¼Œä¸‰äººå¯ç»„ä¸€é˜Ÿã€‚ä¸€é˜Ÿè‡³å°‘æœ‰ $2$ ä¸ªç¬¬äºŒç±»äººï¼Œä¸”æ‰€æœ‰äººäº’ç›¸ä¸è®¤è¯†ã€‚ä¸€å¼€å§‹å¤§å®¶éƒ½ä¸è®¤è¯†ï¼Œç„¶å $n-1$ ä¸ªæ“ä½œï¼Œæ¯æ¬¡ä»‹ç»ä¸¤ä¸ªäººè®¤è¯†ï¼Œæ±‚è¿‡ç¨‹ä¸­èƒ½ç»„å‡ºä¸€ä¸ªé˜Ÿä¼çš„æ–¹æ¡ˆæ•°ï¼Œè®¤è¯†å…·æœ‰ä¼ é€’æ€§ã€‚

é˜Ÿå‹æ¨çš„å…¬å¼ï¼Œè®¾è¿é€šå— $x,y$ å„æœ‰ $A_x,B_x,A_y,B_y$ ä¸ªä¸¤ç±»äººï¼Œè€Œç¬¬äºŒç±»äººæ€»å…±æœ‰ $B$ ä¸ªï¼Œé‚£ä¹ˆåˆå¹¶å®ƒä»¬ä¼šä½¿å¾—ç­”æ¡ˆå‡å° 
$$
B_xB_y(n-A_x-B_x-A_y-B_y) + (A_xB_y+A_yB_x)(B-B_x-B_y)
$$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll mod=1e9+7;
int n,fa[100005];
ll ans,A[100005],B[100005],totA,totB;

int _find(int x){return x==fa[x]?x:fa[x]=_find(fa[x]);}
void _merge(int x,int y)
{
    x=_find(x),y=_find(y);

    ans-=B[x]*B[y]%mod*(n-A[x]-B[x]-A[y]-B[y])%mod;
    ans=(ans+mod)%mod;
    ans-=(A[x]*B[y]+A[y]*B[x])*(totB-B[x]-B[y])%mod;
    ans=(ans+mod)%mod;

    fa[x]=y;A[y]+=A[x],B[y]+=B[x];
}

void solve()
{
    scanf("%d",&n);
    totA=totB=0;
    for(int i=1,x;i<=n;i++)
    {
        fa[i]=i;
        scanf("%d",&x);
        A[i]=B[i]=0;
        if(x==1) A[i]=1,totA++; else B[i]=1,totB++;
    }
    ans=totB*(totB-1)*(totB-2)/6%mod+totB*(totB-1)/2*totA%mod;
    ans%=mod;
    printf("%lld\n",ans);
    for(int i=1,x,y;i<n;i++)
    {
        scanf("%d%d",&x,&y);
        _merge(x,y);
        printf("%lld\n",ans);
    }
}

int main()
{
    int _;
    scanf("%d",&_);
    while(_--) solve();
    return 0;
}
```



### H. Triangle Collision (å‡ ä½•)

ç»™å®šåˆå§‹åæ ‡å’Œè¿åŠ¨æ–¹å‘ä¸é€Ÿåº¦ï¼Œé—®è´¨ç‚¹åœ¨è¾¹é•¿ $L$ çš„ç­‰è¾¹ä¸‰è§’å½¢å†…ç¬¬ $k$ æ¬¡ç¢°æ’çš„æ—¶é—´ã€‚

æŠŠç­‰è¾¹ä¸‰è§’å½¢å¹³é“ºå¹³é¢ï¼Œç¬¬ $k$ æ¬¡ç¢°æ’ç­‰ä»·äºç¬¬ $k$ æ¬¡ä¸ç›´çº¿ç›¸äº¤ï¼ŒäºŒåˆ†ç­”æ¡ˆå³å¯ã€‚

å†™çš„æ¯”è¾ƒä¸‘ï¼Œäº‹å®ä¸Šå®Œå…¨ä¸éœ€è¦å‡ ä½•çš„æ¿å­...

```cpp
#include <bits/stdc++.h>
using namespace std;

#define db double
const db EPS=1e-9;
inline int sign(db a){return a<-EPS?-1:a>EPS;}
inline int cmp(db a,db b){return sign(a-b);}
struct P
{
    db x,y;
    P(){}
    P(db x,db y):x(x),y(y){}
    P operator+(P p){return {x+p.x,y+p.y};}
    P operator-(P p){return {x-p.x,y-p.y};}
    P operator*(db d){return {x*d,y*d};}
    P operator/(db d){return {x/d,y/d};}
    bool operator<(P p) const
    {
        int c=cmp(x,p.x);
        if(c) return c==-1;
        return cmp(y,p.y)==-1;
    }
    bool operator==(P o) const
    {
        return cmp(x,o.x)==0&&cmp(y,o.y)==0;
    }
    db distTo(P p){return (*this-p).abs();}
    db alpha(){return atan2(y,x);}
    void read(){scanf("%lf%lf",&x,&y);}
    void write(){printf("(%.10f,%.10f)\n",x,y);}
    db abs(){return sqrt(abs2());}
    db abs2(){return x*x+y*y;}
    P rot90(){return P(-y,x);}
    P unit(){return *this/abs();}
    int quad() const {return sign(y)==1||(sign(y)==0&&sign(x)>=0);}
    db dot(P p){return x*p.x+y*p.y;}
    db det(P p){return x*p.y-y*p.x;}
    P rot(db an){return {x*cos(an)-y*sin(an),x*sin(an)+y*cos(an)};}
};

int compareAngle(P a,P b)
{
    if(a.quad()!=b.quad()) return a.quad()<b.quad();
    return sign(a.det(b))>0;
}

//For segment
#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

bool chkLL(P p1,P p2,P q1,P q2) //0:parallel
{
    db a1=cross(q1,q2,p1),a2=-cross(q1,q2,p2);
    return sign(a1+a2)!=0;
}

P isLL(P p1,P p2,P q1,P q2) //crossover point if chkLL()
{
    db a1=cross(q1,q2,p1),a2=-cross(q1,q2,p2);
    return (p1*a2+p2*a1)/(a1+a2);
}

bool intersect(db l1,db r1,db l2,db r2)
{
    if(l1>r1) swap(l1,r1);if(l2>r2) swap(l2,r2);
    return !(cmp(r1,l2)==-1||cmp(r2,l1)==-1);
}

bool isSS(P p1,P p2,P q1,P q2)
{
    return intersect(p1.x,p2.x,q1.x,q2.x)&&intersect(p1.y,p2.y,q1.y,q2.y)&&
    crossOp(p1,p2,q1)*crossOp(p1,p2,q2)<=0&&crossOp(q1,q2,p1)*crossOp(q1,q2,p2)<=0;
}

bool isSS_strict(P p1,P p2,P q1,P q2)
{
    return crossOp(p1,p2,q1)*crossOp(p1,p2,q2)<0
    &&crossOp(q1,q2,p1)*crossOp(q1,q2,p2)<0;
}

bool isMiddle(db a,db m,db b)
{
    return sign(a-m)==0||sign(b-m)==0||(a<m!=b<m);
}

bool isMiddle(P a,P m,P b)
{
    return isMiddle(a.x,m.x,b.x)&&isMiddle(a.y,m.y,b.y);
}

bool onSeg(P p1,P p2,P q)
{
    return crossOp(p1,p2,q)==0&&isMiddle(p1,q,p2);
}

bool onSeg_strict(P p1,P p2,P q)
{
    return crossOp(p1,p2,q)==0&&sign((q-p1).dot(p1-p2))*sign((q-p2).dot(p1-p2))<0;
}

P proj(P p1,P p2,P q)
{
    P dir=p2-p1;
    return p1+dir*(dir.dot(q-p1)/dir.abs2());
}

const db SQRT3=sqrt(3);
const db SQRT32=sqrt(3)/2;
int k;
db L,x,y,vx,vy;
P P00,P01,P10,P11,P20,P21,st,ed,dir,tmp;

inline int gao(double dis,P &a,P &b,int id)
{
    ed=st+dir*dis;
    if(!chkLL(a,b,st,ed)) return 0;
    db QAQ=st.distTo(proj(a,b,st));
    tmp=isLL(a,b,st,ed);
    if((tmp-st).dot(ed-st)<0) QAQ=SQRT32-QAQ;
    db WTF=st.distTo(proj(ed,ed+b-a,st));
    return int((WTF-QAQ)/SQRT32+0.000001)+1;
}

inline bool check(double dis)
{
    return gao(dis,P00,P01,0)+gao(dis,P10,P11,1)+gao(dis,P20,P21,2)>=k;
}

void solve()
{
    scanf("%lf%lf%lf%lf%lf%d",&L,&x,&y,&vx,&vy,&k);
    st=P(x,y)/L;dir=P(vx,vy).unit();
    db l=0,r=10*k,mid;
    for(int i=0;i<100;i++)
    {
        mid=(l+r)/2;
        ed=st+dir*mid;
        if(!isSS(P00,P01,st,ed)&&!isSS(P10,P11,st,ed)&&!isSS(P20,P21,st,ed)) l=mid;
        else r=mid;
    }
    r=10*k;
    for(int i=0;i<100;i++)
    {
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    db ans=(l+r)/2;
    ans=ans*L/sqrt(vx*vx+vy*vy);
    printf("%.10f\n",ans);
}

int main()
{
    P00=P10=P(-0.5,0);
    P11=P21=P(0,SQRT32);
    P01=P20=P(0.5,0);
    int _;
    scanf("%d",&_);
    while(_--) solve();
    return 0;
}
```



### I. Parentheses Matching (è´ªå¿ƒ)

$n$ é•¿å­—ç¬¦ä¸²ï¼Œæœ‰å·¦å³æ‹¬å·å’Œé€šé…ç¬¦ï¼ŒæŠŠå®ƒå˜æˆæœ€çŸ­æ—¶å­—å…¸åºæœ€å°çš„åˆæ³•æ‹¬å·åºåˆ—ã€‚

å°½é‡æŠŠå·¦æ‹¬å·å¾€å·¦æ”¾ï¼Œå³æ‹¬å·å¾€å³æ”¾ï¼Œæ‰€ä»¥å·¦å³å„æ‰«ä¸€éå°±åšå®Œäº†ã€‚

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
char s[100005];

void solve()
{
    scanf("%s",s);
    n=strlen(s);
    int tot=0;

    for(int i=0,cur=0;i<n;i++)
    {
        if(s[i]=='(') tot++;
        else if(s[i]==')') tot--;
        if(tot<0)
        {
            while(cur<i&&s[cur]!='*') cur++;
            if(s[cur]!='*')
            {
                printf("No solution!\n");
                return;
            }
            s[cur]='(';tot++;
        }
    }

    tot=0;
    for(int i=n-1,cur=n-1;i>=0;i--)
    {
        if(s[i]=='(') tot++;
        else if(s[i]==')') tot--;
        if(tot>0)
        {
            while(cur>i&&s[cur]!='*') cur--;
            if(s[cur]!='*')
            {
                printf("No solution!\n");
                return;
            }
            s[cur]=')';tot--;
        }
    }

    tot=0;
    for(int i=0;i<n;i++)
        if(s[i]=='(') tot++;
        else if(s[i]==')') tot--;

    if(tot!=0)
    {
        printf("No solution!\n");
        return;
    }

    for(int i=0;i<n;i++)
        if(s[i]!='*') printf("%c",s[i]);
    printf("\n");
}

int main()
{
    int _;
    scanf("%d",&_);
    while(_--) solve();
    return 0;
}
```

