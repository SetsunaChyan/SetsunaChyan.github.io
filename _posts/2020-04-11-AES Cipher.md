---
title: "C++ 实现基于 AES 的加密与解密"
categories: [Information Security]
toc: true
classes: []
excerpt: "信息安全实验记录，ECB模式+ZeroPadding"
---



~~终于我还是回到了 C++ 的怀抱~~

$\text{AES}$ 的加密模式有很多种，不过因为实验要求，这里就选用了书上的 $\text{ECB}$ 模式。

对于明文不够一组长度的部分，用 $0\text{x}00$ 填充，所以也叫 $\text{ZeroPadding}$ 。

 一个 $\text{word}$ 长 $32$ 位，一个 $\text{byte}$ 长 $8$ 位。

明文分组长度有 $3$ 种，$128/192/256 \text{ bit}$ ，令 $N_b$ 表示分组长度，单位为一个 $\text{word}$ ，那么就有 $N_b=4/6/8$ 。

同样密钥也有这 $3$ 种选择，令 $N_k$ 表示密钥长度。

加密轮数同时和密钥长度以及明文长度有关，有 $N_r=\max(N_b,N_k)+6$ 。

### 1. 密钥扩展

因为要加密算法要迭代 $N_r$ 轮，我们需要 $N_r+1$ 个长度为 $N_b$ 的密钥，于是就需要把 $N_k$ 长的密钥扩展成 $N_b(N_r+1)$ 长的密钥组。

由一开始密钥中每一个 $\text{word}$ 构成初始密码数组，记为 $w_0,w_1,\dots,w_{N_k-1}$ 。

然后开始扩展，当 $i$ 是 $N_k$ 的倍数时有

$$
w_i=  w_{i-1} \bigoplus w_{i-N_k}
$$

否则有要把 $w_{i-1}$ 按字循环左移，再进行 $S$ 盒变换，然后最高位的那个字异或上轮常量 $RC_j$ 。

轮常量 $RC_j$ 是 $GF(2^8)$ 域上 $x^{i-1}$ 所表示的数值。

当 $N_k=8$ 时还要检查 $i$ 是否模 $8$ 余 $4$ ，如果是则要多进行一次 $S$ 盒变换。

```cpp
static UINT SubWord(UINT x)
{
    UINT ret=SubByte(x>>24)<<24;
    ret|=SubByte((x>>16)&255)<<16;
    ret|=SubByte((x>>8)&255)<<8;
    ret|=SubByte(x&255);
    return ret;
}
static UINT RotWord(UINT x) {return (x<<8)|(x>>24);}
static vector<UINT> KeyExpansion(vector<UINT> &k,int Nb,int Nk,int Nr)
{
    static const UINT RC[11]={0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36};
    vector<UINT> kw;
    UINT tmp;
    for(int i=0;i<Nk;i++)
        kw.push_back((k[4*i]<<24)|(k[4*i+1]<<16)|(k[4*i+2]<<8)|k[4*i+3]);
    for(int i=Nk;i<Nb*(Nr+1);i++)
    {
        tmp=kw[i-1];
        if(i%Nk==0) tmp=SubWord(RotWord(tmp))^(RC[i/Nk]<<24);
        else if(Nk==8&&(i%Nk==4)) tmp=SubWord(tmp);
        kw.push_back(kw[i-Nk]^tmp);
    }
    return kw;
}
```

 

### 2. 字节代换运算 SubBytes

这一步是可逆的非线性字节代换操作，把每个字节求 $GF(2^8)$ 上的乘法逆元，再进行一步仿射变换，有表达式

$$
\left[
	\begin{matrix}
		b_0'\newline b_1'\newline b_2'\newline b_3'\newline b_4'\newline b_5'\newline b_6'\newline b_7'
	\end{matrix} 
\right]
=
\left[
	\begin{matrix}
		1&0&0&0&1&1&1&1\newline 
		1&1&0&0&0&1&1&1\newline 
		1&1&1&0&0&0&1&1\newline 
		1&1&1&1&0&0&0&1\newline 
		1&1&1&1&1&0&0&0\newline 
		0&1&1&1&1&1&0&0\newline 
		0&0&1&1&1&1&1&0\newline 
		0&0&0&1&1&1&1&1\newline 
	\end{matrix} 
\right]
\left[
	\begin{matrix}
		b_0\newline b_1\newline b_2\newline b_3\newline b_4\newline b_5\newline b_6\newline b_7
	\end{matrix} 
\right]
+
\left[
	\begin{matrix}
		1\newline 1\newline 0\newline 0\newline 0\newline 1\newline 1\newline 0
	\end{matrix} 
\right]
$$
逆变换不难求，只要把里面左乘的矩阵用它的逆代替即可。

当然也可以打个表，就是 $S$ 盒变换了。

```cpp
static UINT SubByte(UINT x)
{
    static const UINT S[16][16]={
        {0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x1,0x67,0x2b,0xfe,0xd7,0xab,0x76},
        {0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0},
        {0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15},
        {0x4,0xc7,0x23,0xc3,0x18,0x96,0x5,0x9a,0x7,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75},
        {0x9,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84},
        {0x53,0xd1,0x0,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf},
        {0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x2,0x7f,0x50,0x3c,0x9f,0xa8},
        {0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2},
        {0xcd,0xc,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73},
        {0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0xb,0xdb},
        {0xe0,0x32,0x3a,0xa,0x49,0x6,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79},
        {0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x8},
        {0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a},
        {0x70,0x3e,0xb5,0x66,0x48,0x3,0xf6,0xe,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e},
        {0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf},
        {0x8c,0xa1,0x89,0xd,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0xf,0xb0,0x54,0xbb,0x16}
    };
    return S[x>>4][x&15];
}
static UINT InvSubByte(UINT x)
{
    static const UINT InvS[16][16]={
        {0x52,0x9,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb},
        {0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb},
        {0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0xb,0x42,0xfa,0xc3,0x4e},
        {0x8,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25},
        {0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92},
        {0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84},
        {0x90,0xd8,0xab,0x0,0x8c,0xbc,0xd3,0xa,0xf7,0xe4,0x58,0x5,0xb8,0xb3,0x45,0x6},
        {0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0xf,0x2,0xc1,0xaf,0xbd,0x3,0x1,0x13,0x8a,0x6b},
        {0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73},
        {0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e},
        {0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0xe,0xaa,0x18,0xbe,0x1b},
        {0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4},
        {0x1f,0xdd,0xa8,0x33,0x88,0x7,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f},
        {0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0xd,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef},
        {0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61},
        {0x17,0x2b,0x4,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0xc,0x7d}
    };
    return InvS[x>>4][x&15];
}
static void SubBytes(vector<UINT> state[4],int op)
{
    for(int i=0;i<4;i++)
        for(auto &x:state[i]) 
            if(op==1) x=SubByte(x);
            else x=InvSubByte(x);
}
```



### 3. 行移位变换 ShiftRows

这个操作是同组中 $\text{word}$ 间的混淆。第 $i$ 行循环左移 $C_i$ ，有 $C_i=i-1$ 。

当 $N_k=8$ 时较为特殊，$C_0,C_1$ 符合上式，但 $C_2=3,C_3=4$ 。

```cpp
static void ShiftRows(vector<UINT> state[4],int Nb,int Nk,int op)
{
    int c[4]={0,1,2,3},tmp[Nb];
    if(Nk==8) c[2]=3,c[3]=4;
    for(int i=0;i<(int)state[0].size();i+=Nb)
        for(int j=0;j<4;j++)
        {
            for(int k=0;k<Nb;k++) tmp[k]=state[j][(k+op*c[j]+Nb)%Nb+i];
            for(int k=0;k<Nb;k++) state[j][k+i]=tmp[k];
        }
}
```



### 4. 列混合变换 MixColumns

列混合是对每个 $\text{word}$ (也就是列)的线性变换，对于 $w_i=\{s_{0i}',s_{1i}',s_{2i}',s_{3i}'\}$有
$$
\left[
	\begin{matrix}
		s_{0i}'\newline s_{1i}'\newline s_{2i}'\newline s_{3i}'
	\end{matrix} 
\right]
=
\left[
	\begin{matrix}
		02&03&01&01\newline 
		01&02&03&01\newline 
		01&01&02&03\newline 
		03&01&01&02\newline 
	\end{matrix} 
\right]
\left[
	\begin{matrix}
		s_{0i}\newline s_{1i}\newline s_{2i}\newline s_{3i}
	\end{matrix} 
\right]
$$
它的逆变换是
$$
\left[
	\begin{matrix}
		s_{0i}'\newline s_{1i}'\newline s_{2i}'\newline s_{3i}'
	\end{matrix} 
\right]
=
\left[
	\begin{matrix}
		0e&0b&0d&09\newline 
		09&0e&0b&0d\newline 
		0d&09&0e&0b\newline 
		0b&0d&09&0e\newline 
	\end{matrix} 
\right]
\left[
	\begin{matrix}
		s_{0i}\newline s_{1i}\newline s_{2i}\newline s_{3i}
	\end{matrix} 
\right]
$$
$GF(2^8)$ 域上的乘法可以用人尽皆知的快速乘搞定。

```cpp
static UINT mul(UINT x,UINT y)
{
    UINT ret=0,tmp;
    while(y)
    {
        if(y&1) ret^=x;
        tmp=(x<<1)&255;
        if(x>=128) tmp^=0x1b;
        x=tmp,y>>=1;
    }
    return ret;
}
static void MixColumns(vector<UINT> state[4],int op)
{
    static const UINT pos[4][4]={ {0x2,0x3,0x1,0x1},{0x1,0x2,0x3,0x1},{0x1,0x1,0x2,0x3},{0x3,0x1,0x1,0x2} };
    static const UINT inv[4][4]={ {0x0e,0x0b,0x0d,0x09},{0x09,0x0e,0x0b,0x0d},{0x0d,0x09,0x0e,0x0b},{0x0b,0x0d,0x09,0x0e} };
    int tmp[4];
    for(int col=0;col<(int)state[0].size();col++)
    {
        memset(tmp,0,sizeof(tmp));
        for(int i=0;i<4;i++)
            for(int j=0;j<4;j++)
                if(op==1) tmp[i]^=mul(pos[i][j],state[j][col]);
                else tmp[i]^=mul(inv[i][j],state[j][col]);
        for(int i=0;i<4;i++) state[i][col]=tmp[i];
    }
}
```



### 5. 轮密钥加变换 AddRoundKey

其实就是把生成的对应轮次的密钥直接加到状态上。

```cpp
static void AddRoundKey(vector<UINT> state[4],vector<UINT> &kw,int st,int Nb)
{
    for(int T=0;T<(int)state[0].size();T+=Nb)
        for(int i=0;i<Nb;i++)
        {
            state[0][T+i]^=kw[i+st]>>24;
            state[1][T+i]^=(kw[i+st]>>16)&255;
            state[2][T+i]^=(kw[i+st]>>8)&255;
            state[3][T+i]^=kw[i+st]&255;
        }
}
```



### 6. 加密与解密过程

由于解密其实就是把加密倒过来做一遍，代码几乎是可以完全重用的。

```cpp
//encrypt
kw=KeyExpansion(k,Nb,Nk,Nr);
AddRoundKey(state,kw,0,Nb);
for(int r=1;r<Nr;r++)
{
    SubBytes(state,1);
    ShiftRows(state,Nb,Nk,1);
    MixColumns(state,1);
    AddRoundKey(state,kw,r*Nb,Nb);
}
SubBytes(state,1);
ShiftRows(state,Nb,Nk,1);
AddRoundKey(state,kw,Nr*Nb,Nb);

//decrypt
kw=KeyExpansion(k,Nb,Nk,Nr);
AddRoundKey(state,kw,Nr*Nb,Nb);
ShiftRows(state,Nb,Nk,-1);
SubBytes(state,-1);
for(int r=Nr-1;r>0;r--)
{
    AddRoundKey(state,kw,r*Nb,Nb);
    MixColumns(state,-1);
    ShiftRows(state,Nb,Nk,-1);
    SubBytes(state,-1);
}
AddRoundKey(state,kw,0,Nb);
```

